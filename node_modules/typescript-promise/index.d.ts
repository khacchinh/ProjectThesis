/**
 * Main TypeScript Promise class.
 *
 * @export
 * @class TSPromise
 * @template R
 */
export declare class TSPromise<R> {
    /**
     * Creates an instance of TSPromise.
     *
     * First function is called right away, the first argument of this function should be called once the promise resolves succesfully.
     * The second argument can be called if the promise fails.  Any number of arguments can be used for either function.
     *
     * The second argument is a specific scope to call all .then functions through
     *
     * @param {(success: (...args) => void, failure?: (...args) => void) => void} [func]
     *
     * @memberOf TSPromise
     */
    constructor(func?: (success: (...args: Array<any>) => void, failure?: (...args: Array<any>) => void) => void);
    /**
     * Manually resolve the promise.
     *
     * @param {...Array<any>} values
     *
     * @memberOf TSPromise
     */
    resolve(...values: Array<any>): void;
    /**
     * Manually reject the promise.
     *
     * @param {...Array<any>} reasons
     *
     * @memberOf TSPromise
     */
    reject(...reasons: Array<any>): void;
    /**
     * Perform an action after the promise completes.
     *
     * @param {(...args) => void} onSuccess
     * @param {(...args) => void} [onFail]
     * @returns {TSPromise<R>}
     *
     * @memberOf TSPromise
     */
    then(onSuccess: (...args: Array<any>) => void, onFail?: (...args: Array<any>) => void): TSPromise<R>;
    /**
     * Catch any errors resulting from the promises.
     *
     * @param {(...args) => void} cfn
     * @returns {TSPromise<R>}
     *
     * @memberOf TSPromise
     */
    catch(cfn: (...args: Array<any>) => void): TSPromise<R>;
    /**
     * Complete all promises passed to this function, then trigger a resulting promise when they're all done.
     *
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     *
     * @memberOf TSPromise
     */
    static all(promises: Array<TSPromise<any>>): TSPromise<any>;
    /**
     * Chain a set of promises so that one runs after another, then trigger a final promise once they're all done.
     *
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     *
     * @memberOf TSPromise
     */
    static chain(promises: Array<TSPromise<any>>): TSPromise<any>;
    /**
     * Trigger a set of promises and resolve a final promise when the first of the initial promises completes.
     *
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     *
     * @memberOf TSPromise
     */
    static race(promises: Array<TSPromise<any>>): TSPromise<any>;
}

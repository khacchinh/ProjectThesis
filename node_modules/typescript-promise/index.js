"use strict";
var f = "function";
/**
 * Main TypeScript Promise class.
 *
 * @export
 * @class TSPromise
 * @template R
 */
var TSPromise = (function () {
    /**
     * Creates an instance of TSPromise.
     *
     * First function is called right away, the first argument of this function should be called once the promise resolves succesfully.
     * The second argument can be called if the promise fails.  Any number of arguments can be used for either function.
     *
     * The second argument is a specific scope to call all .then functions through
     *
     * @param {(success: (...args) => void, failure?: (...args) => void) => void} [func]
     *
     * @memberOf TSPromise
     */
    function TSPromise(func) {
        var _this = this;
        if (func) {
            func(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                _this.resolve.apply(_this, args);
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                _this.reject.apply(_this, args);
            });
        }
    }
    /**
     * Manually resolve the promise.
     *
     * @param {...Array<any>} values
     *
     * @memberOf TSPromise
     */
    TSPromise.prototype.resolve = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        this._done(1, values);
    };
    /**
     * Manually reject the promise.
     *
     * @param {...Array<any>} reasons
     *
     * @memberOf TSPromise
     */
    TSPromise.prototype.reject = function () {
        var reasons = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            reasons[_i] = arguments[_i];
        }
        this._done(-1, reasons);
    };
    /**
     * Complete the promise in it's final state.
     *
     * @internal
     * @param {number} state
     * @param {Array<any>} value
     * @returns {void}
     *
     * @memberOf TSPromise
     */
    TSPromise.prototype._done = function (state, value) {
        var t = this;
        if (t._state || value[0] === t)
            return;
        if (state === 1) {
            if (value[0] && (typeof value[0] === f || typeof value[0] === "object")) {
                if (typeof value[0].then === f) {
                    value[0].then.call(value[0], function () {
                        var ra = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            ra[_i] = arguments[_i];
                        }
                        t.resolve.apply(t, ra);
                    }, function () {
                        var rr = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            rr[_i] = arguments[_i];
                        }
                        t.reject.apply(t, rr);
                    });
                    return;
                }
            }
        }
        t._state = state;
        t._values = value;
        if (t._tasks) {
            t._tasks.forEach(function (task) {
                if (state === 1)
                    TSPromise._resolveTask(task, t._values);
                if (state === -1)
                    TSPromise._rejectTask(task, t._values);
            });
        }
    };
    /**
     * Perform an action after the promise completes.
     *
     * @param {(...args) => void} onSuccess
     * @param {(...args) => void} [onFail]
     * @returns {TSPromise<R>}
     *
     * @memberOf TSPromise
     */
    TSPromise.prototype.then = function (onSuccess, onFail) {
        var p = new TSPromise();
        var t = this;
        var task = {
            promise: p,
            successFunc: onSuccess,
            failFunc: onFail
        };
        if (!t._state) {
            if (t._tasks) {
                t._tasks.push(task);
            }
            else {
                t._tasks = [task];
            }
        }
        else {
            if (t._state === 1)
                TSPromise._resolveTask(task, t._values);
            else
                TSPromise._rejectTask(task, t._values);
        }
        return p;
    };
    /**
     * Catch any errors resulting from the promises.
     *
     * @param {(...args) => void} cfn
     * @returns {TSPromise<R>}
     *
     * @memberOf TSPromise
     */
    TSPromise.prototype.catch = function (cfn) {
        return this.then(function () { }, cfn);
    };
    ;
    /**
     * Complete all promises passed to this function, then trigger a resulting promise when they're all done.
     *
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     *
     * @memberOf TSPromise
     */
    TSPromise.all = function (promises) {
        var result = [];
        return new TSPromise(function (res, rej) {
            if (promises && promises.length) {
                promises.forEach(function (pr) {
                    pr.then(function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        result.push(args);
                        if (result.length === promises.length) {
                            res(result);
                        }
                    });
                });
            }
            else {
                res([]);
            }
        });
    };
    /**
     * Chain a set of promises so that one runs after another, then trigger a final promise once they're all done.
     *
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     *
     * @memberOf TSPromise
     */
    TSPromise.chain = function (promises) {
        var index = 0;
        var results = [];
        return new TSPromise(function (res) {
            var nextPromise = function (promise) {
                if (index === promises.length) {
                    res(results);
                }
                else {
                    promise.then(function () {
                        var result = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            result[_i] = arguments[_i];
                        }
                        results.push(result);
                        index++;
                        nextPromise(promises[index]);
                    });
                }
            };
            nextPromise(promises[index]);
        });
    };
    /**
     * Trigger a set of promises and resolve a final promise when the first of the initial promises completes.
     *
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     *
     * @memberOf TSPromise
     */
    TSPromise.race = function (promises) {
        return new TSPromise(function (res, rej) {
            if (promises && promises.length) {
                promises.forEach(function (pr) {
                    pr.then(function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        res.apply(pr, args);
                    });
                });
            }
            else {
                res();
            }
        });
    };
    /**
     * Handle resovling an async promise
     *
     * @internal
     * @static
     * @param {Task} task
     * @param {Array<any>} args
     *
     * @memberOf TSPromise
     */
    TSPromise._resolveTask = function (task, args) {
        TSPromise._done(1, task.successFunc, task, args);
    };
    /**
     * Handle rejecting an async promise.
     *
     * @internal
     * @static
     * @param {Task} task
     * @param {Array<any>} args
     *
     * @memberOf TSPromise
     */
    TSPromise._rejectTask = function (task, args) {
        if (task.failFunc)
            TSPromise._done(-1, task.failFunc, task, args);
    };
    /**
     * Trigger the final actions of an async promise.
     *
     * @internal
     * @static
     * @param {number} type
     * @param {Function} triggerFunc
     * @param {Task} task
     * @param {Array<any>} args
     *
     * @memberOf TSPromise
     */
    TSPromise._done = function (type, triggerFunc, task, args) {
        if (typeof triggerFunc === f) {
            try {
                task.promise.resolve(triggerFunc.apply(task.promise, args));
            }
            catch (err) {
                task.promise.reject(err);
            }
        }
        else {
            if (type === 1)
                task.promise.resolve.apply(task.promise, args);
            if (type === -1)
                task.promise.reject.apply(task.promise, args);
        }
    };
    return TSPromise;
}());
exports.TSPromise = TSPromise;

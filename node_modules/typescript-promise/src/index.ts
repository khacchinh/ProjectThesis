interface Task {
    successFunc: Function;
    failFunc?: Function;
    promise: TSPromise<any>;
}

let f = "function";

/**
 * Main TypeScript Promise class.
 * 
 * @export
 * @class TSPromise
 * @template R
 */
export class TSPromise<R> {

    /**
     * Holds the promise state
     * 
     * @internal
     * @type {number}
     * @memberOf TSPromise
     */
    public _state: number;

    /**
     * Holds the value of the promise.
     * 
     * @internal
     * @type {Array<R>}
     * @memberOf TSPromise
     */
    public _values: Array<R>;

    /**
     * Holds an array of async promises to resolve.
     * 
     * @internal
     * @type {Array<Task>}
     * @memberOf TSPromise
     */
    public _tasks: Array<Task>;


    /**
     * Creates an instance of TSPromise.
     * 
     * First function is called right away, the first argument of this function should be called once the promise resolves succesfully.
     * The second argument can be called if the promise fails.  Any number of arguments can be used for either function.
     * 
     * The second argument is a specific scope to call all .then functions through
     * 
     * @param {(success: (...args) => void, failure?: (...args) => void) => void} [func]
     * 
     * @memberOf TSPromise
     */
    constructor(func?: (success: (...args: Array<any>) => void, failure?: (...args: Array<any>) => void) => void) {
        if (func) {
            func((...args: Array<any>) => {
                this.resolve.apply(this, args);
            }, (...args: Array<any>) => {
                this.reject.apply(this, args);
            });
        }
    }

    /**
     * Manually resolve the promise.
     * 
     * @param {...Array<any>} values
     * 
     * @memberOf TSPromise
     */
    public resolve(...values: Array<any>): void {
        this._done(1, values);
    }

    /**
     * Manually reject the promise.
     * 
     * @param {...Array<any>} reasons
     * 
     * @memberOf TSPromise
     */
    public reject(...reasons: Array<any>): void {
        this._done(-1, reasons);
    }

    /**
     * Complete the promise in it's final state.
     * 
     * @internal
     * @param {number} state
     * @param {Array<any>} value
     * @returns {void}
     * 
     * @memberOf TSPromise
     */
    private _done(state: number, value: Array<any>): void {
        let t = this;

        if (t._state || value[0] === t) return;

        if (state === 1) {
            if (value[0] && (typeof value[0] === f || typeof value[0] === "object")) {
                if (typeof value[0].then === f) {
                    value[0].then.call(value[0],
                        (...ra: Array<any>) => { t.resolve.apply(t, ra); },
                        (...rr: Array<any>) => { t.reject.apply(t, rr); });
                    return;
                }
            }
        }

        t._state = state;
        t._values = value;

        if (t._tasks) {
            t._tasks.forEach((task) => {
                if (state === 1) TSPromise._resolveTask(task, t._values);
                if (state === -1) TSPromise._rejectTask(task, t._values);
            });
        }

    }


    /**
     * Perform an action after the promise completes.
     * 
     * @param {(...args) => void} onSuccess
     * @param {(...args) => void} [onFail]
     * @returns {TSPromise<R>}
     * 
     * @memberOf TSPromise
     */
    public then(onSuccess: (...args: Array<any>) => void, onFail?: (...args: Array<any>) => void): TSPromise<R> {
        let p = new TSPromise<R>();
        let t = this;
        let task: Task = {
            promise: p,
            successFunc: onSuccess,
            failFunc: onFail
        };

        if (!t._state) {
            if (t._tasks) {
                t._tasks.push(task);
            } else {
                t._tasks = [task];
            }
        } else {
            if (t._state === 1)
                TSPromise._resolveTask(task, t._values);
            else
                TSPromise._rejectTask(task, t._values);
        }

        return p;
    }

    /**
     * Catch any errors resulting from the promises.
     * 
     * @param {(...args) => void} cfn
     * @returns {TSPromise<R>}
     * 
     * @memberOf TSPromise
     */
    public catch(cfn: (...args: Array<any>) => void): TSPromise<R> {
        return this.then(() => {}, cfn);
    };

    /**
     * Complete all promises passed to this function, then trigger a resulting promise when they're all done.
     * 
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static all(promises: Array<TSPromise<any>>): TSPromise<any> {
        let result: Array<any> = [];
        return new TSPromise((res, rej) => {
            if (promises && promises.length) {
                promises.forEach((pr) => {
                    pr.then((...args) => {
                        result.push(args);
                        if (result.length === promises.length) {
                            res(result);
                        }
                    });
                });

            } else {
                res([]);
            }
        });
    }

    /**
     * Chain a set of promises so that one runs after another, then trigger a final promise once they're all done.
     * 
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static chain(promises: Array<TSPromise<any>>): TSPromise<any> {
        let index = 0;
        let results: Array<any> = [];
        return new TSPromise(function (res) {
            let nextPromise = (promise: TSPromise<any>) => {
                if (index === promises.length) {
                    res(results);
                }
                else {
                    promise.then((...result) => {
                        results.push(result);
                        index++;
                        nextPromise(promises[index]);
                    });
                }
            };
            nextPromise(promises[index]);
        });
    }

    /**
     * Trigger a set of promises and resolve a final promise when the first of the initial promises completes.
     * 
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static race(promises: Array<TSPromise<any>>): TSPromise<any> {
        return new TSPromise((res, rej) => {
            if (promises && promises.length) {
                promises.forEach((pr) => {
                    pr.then((...args) => {
                        res.apply(pr, args);
                    });
                });
            } else {
                res();
            }
        });
    }

    /**
     * Handle resovling an async promise
     * 
     * @internal
     * @static
     * @param {Task} task
     * @param {Array<any>} args
     * 
     * @memberOf TSPromise
     */
    private static _resolveTask(task: Task, args: Array<any>): void {
        TSPromise._done(1, task.successFunc, task, args);
    }

    /**
     * Handle rejecting an async promise.
     * 
     * @internal
     * @static
     * @param {Task} task
     * @param {Array<any>} args
     * 
     * @memberOf TSPromise
     */
    private static _rejectTask(task: Task, args: Array<any>): void {
        if (task.failFunc) TSPromise._done(-1, task.failFunc, task, args);
    }

    /**
     * Trigger the final actions of an async promise.
     * 
     * @internal
     * @static
     * @param {number} type
     * @param {Function} triggerFunc
     * @param {Task} task
     * @param {Array<any>} args
     * 
     * @memberOf TSPromise
     */
    private static _done(type: number, triggerFunc: Function, task: Task, args: Array<any>): void {
        if (typeof triggerFunc === f) {
            try {
                task.promise.resolve(triggerFunc.apply(task.promise, args));
            } catch (err) {
                task.promise.reject(err);
            }
        } else {
            if (type === 1) task.promise.resolve.apply(task.promise, args);
            if (type === -1) task.promise.reject.apply(task.promise, args);
        }
    }
 }